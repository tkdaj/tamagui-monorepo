# tamagui-monorepo — Monorepo Overview

This repository is a TypeScript-first monorepo scaffold using `pnpm` and Turborepo. It's designed to host multiple platform apps (web, mobile, desktop) and shared internal libraries while enforcing clear import boundaries and strong type-safety for a Supabase backend.

Goals & principles

- TypeScript-first: strict TS config across the workspace and ESM where possible.
- Internal libs: all shared UI, auth, and logic live under `lib/*` and are private to the monorepo.
- Clear boundaries: apps may not import from other apps; apps import only from `lib/*`.
- Developer ergonomics: root scripts, simple scaffolding scripts, and Husky hooks for nice DX.

Repository layout (high level)

- apps/
  - web/ — TanStack Start-based web app
  - mobile/ — React Native (Expo) app
  - desktop/ — Electron + Vite renderer
- lib/
  - auth/ — Supabase client factory + shared Login view
  - ui/ — shared UI (Tamagui primitives, pages/components)
  - db/ — generated Supabase types + DB helpers
  - config/, utils/, api/ — shared helpers and configuration
- scripts/ — repository helper scripts (clean, new-lib, new-app, supabase types, boundaries checker)
- .github/workflows/ci.yml — CI checks

Key choices and rationale

- pnpm + Turborepo: deterministic dependency management and fast monorepo task orchestration.
- TypeScript: `tsconfig.base.json` enforces strict, modern settings (ES2022, `noUncheckedIndexedAccess`, etc.).
- Tamagui (`lib/ui`): chosen as the cross-platform UI system so design primitives can be shared across web/mobile/desktop.
- Supabase: chosen for auth + realtime DB. We generate a `Database` TypeScript type and wire it into `createSupabaseClient` so all queries can be typed.
- ESLint + import/no-restricted-paths: enforces import boundaries at lint time. A repository-level script `scripts/check-boundaries.mjs` provides an additional filesystem-aware check used by CI.
- Husky + lint-staged + commitlint: pre-commit formatting and linting, commit message convention enforcement.

Scripts (root)

- `pnpm install` — installs workspace deps (Corepack recommended)
- `pnpm dev` — `turbo run dev` (runs dev for all apps)
- `pnpm dev:web|dev:mobile|dev:desktop` — run dev for a single app
- `pnpm build` — `turbo run build`
- `pnpm lint` / `pnpm lint:fix` — lint tasks
- `pnpm typecheck` — workspace type-check
- `pnpm format` / `pnpm format:check` — Prettier
- `pnpm test` — workspace test tasks (Vitest/Jest as configured per package)

Helper scripts (in `scripts/`)

- `pnpm run scripts:clean` — fast cleanup of `dist`, `build`, `.turbo`, etc. Supports `--all` to also remove `node_modules` directories.
- `pnpm run scripts:new-lib <name>` — scaffolds `lib/<name>` with `package.json`, `tsconfig.json`, and `src/index.ts`.
- `pnpm run scripts:new-app <name>` — scaffolds a minimal `apps/<name>` placeholder.
- `pnpm run scripts:supabase-types` — runs `supabase` CLI to generate `lib/db/src/types/database.ts`. If credentials are not present it can write a placeholder (use `--force` to force placeholder).
- `pnpm run scripts:check-boundaries` — repository checker for cross-app imports (additionally run in CI).

Supabase and types workflow

- The authoritative DB TypeScript types live at `lib/db/src/types/database.ts` (generated by the Supabase CLI).
- Workflow:
  1.  Run `pnpm run scripts:supabase-types` after schema changes (requires `SUPABASE_URL` and `SUPABASE_SERVICE_ROLE_KEY` in env when generating).
  2.  Commit the generated `lib/db/src/types/database.ts` so CI and other devs use the same types.
- CI policy: prefer checked-in generated types. Optionally run `pnpm run scripts:supabase-types` in a protected job with a service key stored as a secret.

Auth & shared Login UI

- `lib/auth` contains a `createSupabaseClient` factory typed with `Database` and a shared `LoginView` (used by apps via `lib/ui` components).
- Platform-specific storage adapters (web localStorage, mobile SecureStore, desktop OS keychain) should be implemented in each app and passed into the client factory.

ESLint and import boundaries

- ESLint config enforces: apps may NOT import other apps; libs may NOT import apps.
- The CI runs `pnpm run scripts:check-boundaries` to guarantee repository-level enforcement.

Husky, lint-staged, commitlint

- Pre-commit: `lint-staged` runs Prettier + ESLint fixes on staged files.
- Commit-msg: `commitlint` ensures conventional commit messages.
- Run `pnpm install` locally to enable Husky hooks (the `prepare` script triggers Husky on install).

CI (GitHub Actions)

- The CI workflow `.github/workflows/ci.yml` performs:
  - `pnpm install --frozen-lockfile`
  - `pnpm run format:check`
  - `pnpm run lint`
  - `pnpm run typecheck`
  - `pnpm run test`
  - `pnpm run scripts:check-boundaries`

Testing / Storybook

- Not fully scaffolded across the workspace by default. Recommended next steps:
  - Add `vitest` and a sample unit test to `lib/*` packages.
  - Add Storybook for `lib/ui` and a single baseline story for visual regression.

Security notes

- Never commit secrets (service role keys, SENTRY_AUTH_TOKEN, etc.). Use a `.env` local file and CI secrets.

How to add a new lib or app

- New lib: `pnpm run scripts:new-lib mylib` -> edit `lib/mylib/src/index.ts`.
- New app: `pnpm run scripts:new-app myapp` -> customize bundler/entrypoint for platform.

Definition of done for new features

- Add tests (unit) + Storybook story if UI changes.
- Run `pnpm run scripts:check-boundaries` and `pnpm run lint` and `pnpm run typecheck` locally.

Contact / Contributing

- Follow commit conventions. Use `pnpm run scripts:new-lib` / `scripts:new-app` for scaffolding. Open a PR against `main` and CI will run checks.
